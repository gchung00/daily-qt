import { list, put, del } from '@vercel/blob';
import { readdir, readFile, writeFile, unlink, access, mkdir } from 'fs/promises';
import { join } from 'path';

// @ts-ignore - Data file generated by script
import staticSermonsData from '@/data/sermons.json';

const SERMONS_DIR = join(process.cwd(), 'sermons');

// Type assertion since JSON import might be untyped
const staticSermonsCache = staticSermonsData as Record<string, string>;

function getStaticSermons() {
    return staticSermonsCache || {};
}

export const SermonStorage = {
    async listSermons(): Promise<string[]> {
        // Priority 1: Static JSON (Fastest, Free, Reliable)
        const staticData = getStaticSermons();
        const uniqueDates = new Set(Object.keys(staticData || {}));

        // Priority 2: Vercel Blob (For NEW uploads)
        // Check Blob for new items not in JSON.
        if (process.env.BLOB_READ_WRITE_TOKEN) {
            try {
                let hasMore = true;
                let cursor: string | undefined;

                while (hasMore) {
                    // Fetch page of blobs
                    const response = await list({ prefix: 'sermons/', cursor });

                    // Add items from this page
                    response.blobs.forEach(blob => {
                        const date = blob.pathname.replace('sermons/', '').replace('.txt', '');
                        uniqueDates.add(date);
                    });

                    // Prepare for next page
                    hasMore = response.hasMore;
                    cursor = response.cursor;
                }
            } catch (e) {
                console.warn("Blob list failed (using static only):", e);
            }
        }

        return Array.from(uniqueDates).sort((a, b) => b.localeCompare(a));
    },

    async getSermon(date: string): Promise<string | null> {
        // Priority 1: Blob (Dynamic / Updates)
        // Check this FIRST so we can "eject" or "overwrite" static data with new uploads.
        if (process.env.BLOB_READ_WRITE_TOKEN) {
            try {
                // Check if specific blob exists
                // Note: list() with prefix filters by prefix, not exact match unless it's unique
                // But efficient enough for single file check? 
                // Actually head() or just trying to fetch URL might be better but we need the URL first.
                // list() is fine for finding one file generally.
                const { blobs } = await list({ prefix: `sermons/${date}.txt`, limit: 1 });
                const blob = blobs.find(b => b.pathname === `sermons/${date}.txt`);

                if (blob) {
                    const response = await fetch(blob.url);
                    if (response.ok) {
                        return await response.text();
                    }
                }
            } catch (e) {
                // Ignore blob errors (blocked store), fall back to static
                console.warn(`Blob fetch failed for ${date}, falling back to static:`, e);
            }
        } else {
            // Development: Check local FS before static JSON?
            try {
                const filePath = join(SERMONS_DIR, `${date}.txt`);
                const content = await readFile(filePath, 'utf-8');
                return content;
            } catch (e) {
                // File not found locally, proceed to static JSON
            }
        }

        // Priority 2: Static JSON (Fallback / Archive)
        const staticData = getStaticSermons();
        if (staticData && staticData[date]) {
            return staticData[date];
        }

        return null; // Not found anywhere
    },

    async saveSermon(date: string, text: string, force: boolean = false): Promise<boolean> {
        const hasToken = !!process.env.BLOB_READ_WRITE_TOKEN;

        // Check availability (unless forced)
        if (!force) {
            const existing = await this.getSermon(date);
            if (existing) return false; // Signal conflict
        }

        if (hasToken) {
            try {
                // Vercel Blob Upload
                // We must use allowOverwrite: true to update existing files when force is true (or even if not, since we checked above)
                // The API error explicitly suggested `allowOverwrite: true`
                await put(`sermons/${date}.txt`, text, {
                    access: 'public',
                    addRandomSuffix: false,
                    // @ts-ignore - The Vercel Blob SDK requires this flag for overwrites, ignoring TS warning if types are old
                    allowOverwrite: true
                });
                return true;
            } catch (e: any) {
                console.error("Blob upload failed:", e);
                throw new Error(`Blob Upload Failed: ${e.message || e}`);
            }
        } else {
            // Local Development (File System)
            try {
                await ensureDir();
                const filePath = join(SERMONS_DIR, `${date}.txt`);
                await writeFile(filePath, text, 'utf-8');
                return true;
            } catch (e: any) {
                console.error("FS write failed:", e);
                throw new Error(`File Write Failed: ${e.message || e}`);
            }
        }
    },

    async deleteSermon(date: string): Promise<void> {
        if (process.env.BLOB_READ_WRITE_TOKEN) {
            try {
                const { blobs } = await list({ prefix: `sermons/${date}.txt` });
                const urls = blobs.filter(b => b.pathname === `sermons/${date}.txt`).map(b => b.url);
                if (urls.length > 0) await del(urls);
            } catch (e) {
                console.warn("Blob delete failed:", e);
            }
        } else {
            const filePath = join(SERMONS_DIR, `${date}.txt`);
            try { await unlink(filePath); } catch { }
        }
    }
};

async function ensureDir() {
    try {
        await access(SERMONS_DIR);
    } catch {
        await mkdir(SERMONS_DIR, { recursive: true });
    }
}

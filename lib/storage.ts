import { list, put, del } from '@vercel/blob';
import { readdir, readFile, writeFile, unlink, access, mkdir } from 'fs/promises';
import { join } from 'path';

// @ts-ignore - Data file generated by script
import staticSermonsData from '@/data/sermons.json';

const SERMONS_DIR = join(process.cwd(), 'sermons');

// Type assertion since JSON import might be untyped
const staticSermonsCache = staticSermonsData as Record<string, string>;

function getStaticSermons() {
    return staticSermonsCache || {};
}


export const SermonStorage = {
    async listSermons(): Promise<string[]> {
        // Priority 1: Static JSON (Fastest, Free, Reliable)
        const staticData = getStaticSermons();
        const uniqueDates = new Set(Object.keys(staticData || {}));

        // Priority 2: Vercel Blob (For NEW uploads)
        // Check Blob for new items not in JSON.
        if (process.env.BLOB_READ_WRITE_TOKEN) {
            try {
                const { blobs } = await list({ prefix: 'sermons/' });
                blobs.forEach(blob => {
                    const date = blob.pathname.replace('sermons/', '').replace('.txt', '');
                    uniqueDates.add(date);
                });
            } catch (e) {
                console.warn("Blob list failed (using static only):", e);
            }
        }

        return Array.from(uniqueDates).sort((a, b) => b.localeCompare(a));
    },

    async getSermon(date: string): Promise<string | null> {
        // Priority 1: Static JSON
        const staticData = getStaticSermons();
        if (staticData && staticData[date]) {
            return staticData[date];
        }

        // Priority 2: Blob (Fallback for new items not in JSON?)
        if (process.env.BLOB_READ_WRITE_TOKEN) {
            try {
                const { blobs } = await list({ prefix: `sermons/${date}.txt` });
                const blob = blobs.find(b => b.pathname === `sermons/${date}.txt`);
                if (blob) {
                    const response = await fetch(blob.url);
                    return await response.text();
                }
            } catch (e) {
                // Ignore blob errors (blocked store)
                console.warn("Blob fetch failed (likely blocked):", e);
            }
        }

        return null; // Not found anywhere
    },

    async saveSermon(date: string, text: string, force: boolean = false): Promise<boolean> {
        // Saving requires Blob or FS. 
        // If Production & Blocked -> We cannot save new sermons easily via Admin UI.
        // We will try Blob, but it might fail.

        const hasToken = !!process.env.BLOB_READ_WRITE_TOKEN;

        // Check availability
        if (!force) {
            const existing = await this.getSermon(date);
            if (existing) return false;
        }

        if (hasToken) {
            try {
                await put(`sermons/${date}.txt`, text, {
                    access: 'public',
                    addRandomSuffix: false
                });
                return true;
            } catch (e) {
                console.error("Blob upload failed:", e);
                // Fallback? No fallback in Vercel Serverless for permanent storage
                throw new Error("Storage is currently blocked or unavailable.");
            }
        } else {
            // Development
            await ensureDir();
            const filePath = join(SERMONS_DIR, `${date}.txt`);
            await writeFile(filePath, text, 'utf-8');

            // Also update local JSON cache if possible?
            // Re-saving to JSON in dev is complex, just rely on file.
            return true;
        }
    },

    async deleteSermon(date: string): Promise<void> {
        if (process.env.BLOB_READ_WRITE_TOKEN) {
            try {
                const { blobs } = await list({ prefix: `sermons/${date}.txt` });
                const urls = blobs.filter(b => b.pathname === `sermons/${date}.txt`).map(b => b.url);
                if (urls.length > 0) await del(urls);
            } catch (e) {
                console.warn("Blob delete failed:", e);
            }
        } else {
            const filePath = join(SERMONS_DIR, `${date}.txt`);
            try { await unlink(filePath); } catch { }
        }
    }
};

async function ensureDir() {
    try {
        await access(SERMONS_DIR);
    } catch {
        await mkdir(SERMONS_DIR, { recursive: true });
    }
}

